---
# Author

author:
name: TayLock
url: https://iwantdaydayup.github.io

# Date

date: 2025-06-14

# Original

# isOriginal: true

# Category

category:
  - Algorithm
  - AtCoder Beginner Contest

# Tag

tag:
  - Vertex Multiplexing
  - DP
---

# 🧩 AtCoder Beginner Contest 410

## # Info & Summary

- **Date**: `2025-06-14`
- **Completion Status**: A ✅ / B ✅ / C ✅ / D ✅ / E ❌ / F ❌ / G ❌
- **Problem Type**:

| Problem |    Type(s)    | Data Structure / Algo | 🔥 Key Insight / Mark |
| :-----: | :-----------: | :-------------------: | :-------------------: |
| [D](#D) | XOR operation |  Vertex Multiplexing  |         ⭐🔥          |
| [E](#E) |      DP       |          DP           |       ⚠️🧠🛠️🌀        |
| [F](#F) |     Math      |    Zero-Sum Ranges    |          🌀           |
| [G](#G) |      DP       |          DP           |          🌀           |

<!-- @include: ../Readme.md#Emoji -->

---

## 📌 A - G1{#A}

![410A](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/410A.4ub6uc2cfs.png)

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;

    vector<int> A(N);
    for (int i = 0; i < N; i++)
    {
        cin >> A[i];
    }

    int K;
    cin >> K;

    int ans = 0;

    for (int i = 0; i < N; i++)
    {
        ans += K <= A[i];
    }

    cout << ans << endl;

    return 0;
}
```

## 📌 B - Reverse Proxy{#B}

![410B](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/410B.5q7oaybbbt.png)

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, Q;
    cin >> N >> Q;

    vector<int> A(N);
    for (int i = 0; i < Q; i++)
    {
        int X;
        cin >> X;

        if (X >= 1)
        {
            X--;
        } else {
            X = min_element(A.begin(), A.end()) - A.begin();
        }

        A[X]++;

        cout << X + 1 << " \n"[i == Q - 1];
    }

    return 0;
}
```

## 📌 C - Rotatable Array{#C}

![410C](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/410C.3nrvmwcqai.png)

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, Q;
    cin >> N >> Q;

    vector<int> A(N);
    iota(A.begin(), A.end(), 1);

    int cnt = 0;

    while (Q--)
    {
        int o;
        cin >> o;

        if (o == 1)
        {
            int p, x;
            cin >> p >> x;
            p--;

            A[(p + cnt) % N] = x;
        }
        else if (o == 2)
        {
            int p;
            cin >> p;
            p--;

            cout << A[(p + cnt) % N] << endl;
        }
        else
        {
            int k;
            cin >> k;

            cnt = (cnt + k) % N;
        }
    }

    return 0;
}
```

## 📌 D - XOR Shortest Walk{#D}

![410D](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/410D.86twpvi78b.png)

::: tip
This problem can be solved with a technique informally called `vertex multiplexing`

The original graph $G$ can be mapped to a new graph $G'$ with additional states to handle the `XOR` of edge weights during the walk:

- Vertices of $G'$:
  - $G'$ is a new graph where each vertex $(x, s)$ represents vertex $x$ in the original graph, but with an additional state $s$ (the `XOR` of weights along the path so far)
  - There are $1024$ possible states $s$ for each vertex since `XOR` results are bounded by $2^{10}$
- Edges in $G'$:
  - An edge $(x, s) \rightarrow (y, s \oplus w)$ exists in $G'$ if and only if there is an edge from vertex $x$ to vertex $y$ in $G$ with weight $w$
  - The edge weight in $G'$ is the `XOR` of the current state and the edge weight $w$ in the original graph
- $G'$ is a graph with $1024$ vertices $(1, 0), (1, 1), ..., (1, 1023), (2, 0), (2, 1), ..., (2, 1023), ..., (N, 0), ..., (N, 1023)$, as the edge weight can go up to $2^{10}$, to manage the different `XOR` possibilities

Reachability in $G'$:

- A vertex $(x, s)$ is reachable from vertex $(1, 0)$ in $G'$ if and only if there is an walk from vertex $1$ to vertex $x$ in the original graph with an `XOR` of $s$

Hence, it is sufficient to check if each of vertices $(N, 0), (N, 1), ..., (N, 1023)$ is reachable from vertex $(1, 0)$

Since the graph $G'$ has $1024N$ vertices and $1024M$ edges, the problem can be solved in $O((N + M)\max W_i)$ time by actually constructing the graph and performing `BFS` or `DFS` on it
:::

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M;
    cin >> N >> M;

    vector<vector<pair<int, int>>> adj(N);
    for (int i = 0; i < M; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        u--;
        v--;

        adj[u].push_back({v, w});
    }

    constexpr int K = 1 << 10;

    vector<vector<bool>> vis(N, vector<bool>(K));
    vis[0][0] = true;

    int ans = -1;
    queue<pair<int, int>> q;
    q.push({0, 0});

    while (!q.empty())
    {
        auto [u, value] = q.front();
        q.pop();

        if (u == N - 1 && (ans == -1 || ans > value))
        {
            ans = value;
        }

        for (auto [v, w] : adj[u])
        {
            w ^= value;
            if (!vis[v][w])
            {
                vis[v][w] = true;
                q.push({v, w});
            }
        }
    }

    cout << ans << endl;

    return 0;
}
```

## 📌 E - Battles in a Row{#E}

![410E](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/410E.96a031kye5.png)

::: tip
This problem can be solved with `DP`

> Let $dp[i][m]$: be the maximum health after defeating the first $i$ monsters with exactly $m$ magic power remaining after the $i$-th battle, if the magic power can never become $m$ at that point, let it be $-1$

To determine $dp[i][m]$, we consider two possibilities:

- Fight without using magic: This is possible if Takahashi has at least $A_i$ health
  - The new health is: $dp[i - 1][m] - A_i$
- Fight with magic: This is possible if Takahashi has at least $B_i$ magic power
  - The new magic power is: $m - B_i$

Thus, the state transition is:

$$dp[i][m] = \max(dp[i - 1][m] - A_i, dp[i - 1][m + B_i])$$

If a state is invalid, we return the negative value indicating that the monster cannot be defeated

And the sought answer will be found in $dp[N][m]$
:::

```cpp

```

## 📌 F - Balanced Rectangles{#F}

![410F](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/410F.39lfw14ffi.png)

::: warning
Hard Problems to Tackle Later
:::

```cpp
// TODO
```

## 📌 G - Longest Chord Chain{#G}

![410G](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/410G.3rbhkm5t0f.png)

::: warning
Hard Problems to Tackle Later
:::

```cpp
// TODO
```
