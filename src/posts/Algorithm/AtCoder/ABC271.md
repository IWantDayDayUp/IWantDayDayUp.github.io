---
# Author
author:
name: TayLock
url: https://iwantdaydayup.github.io

# Date
date: 2022-10-01

# Original
# isOriginal: true

# Category
category:
  - Algorithm
  - AtCoder Beginner Contest

# Tag
tag:
  - DP
  - Binary Search
  - Meet-in-the-middle
---

# ðŸ§© AtCoder Beginner Contest 271

## # Info & Summary

- **Date:** `2022-10-01`
- **Completion Status:** A âœ… / B âœ… / C âœ… / D âœ… / E âŒ / F âŒ / G âŒ
- **Problem Type**:
  - D: `DP`
  - E: `DP`
  - F: `Meet-in-the-middle`

---

## D. Flip and Adjust (DP)

é¢˜ç›®:

$n$ å¼ å¡ç‰‡, æ­£é¢æ•°å­— $a_i$, èƒŒé¢æ•°å­— $b_i$

ä½ æ¥å†³å®šæ¯å¼ å¡ç‰‡æ­£é¢æœä¸Šè¿˜æ˜¯åé¢æœä¸Š

ä½†æ˜¯æœ€åŽå¡ç‰‡ä¸Šæ˜¾ç¤ºçš„æ•°å­—æ€»å’Œå¿…é¡»ä¸º $s$

æ€è·¯:

å®šä¹‰ $dp[i][j]$: æ˜¯å¦èƒ½ä»Ž $1, 2, ..., i$ å¼ å¡ç‰‡ä¸­å¾—åˆ°æ€»å’Œ $j$

è½¬ç§»:

1. $dp[i + 1][j] = 0$
2. if $dp[i][j] == 1$
   > 2.1: if $j + a_i < s$, åˆ™ $dp[i + 1][j + a_i] = 1$
   >
   > 2.2: if $j + b_i < s$, åˆ™ $dp[i + 1][j + b_i] = 1$

```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n, s;
    cin >> n >> s;

    vector<int> a(n), b(n);
    for (int i = 0; i < n; i++)
    {
        cin >> a[i] >> b[i];
    }

    vector<vector<bool>> dp(n + 1, vector<bool>(s + 1, false));
    dp[0][0] = true;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j <= s; j++)
        {
            if (dp[i][j])
            {
                if (j + a[i] <= s)
                {
                    dp[i + 1][j + a[i]] = true;
                }
                if (j + b[i] <= s)
                {
                    dp[i + 1][j + b[i]] = true;
                }
            }
        }
    }

    if (dp[n][s])
    {
        cout << "Yes" << endl;
        string ans(n, 'H');
        for (int i = n - 1; i >= 0; i--)
        {
            if (s >= a[i] && dp[i][s - a[i]])
            {
                ans[i] = 'H';
                s -= a[i];
            } else {
                ans[i] = 'T';
                s -= b[i];
            }
        }

        cout << ans << endl;
    } else {
        cout << "No" << endl;
    }

    return 0;
}
```

## E. Subsequence Path (DP)

é¢˜ç›®:

çŽ°åœ¨æœ‰ $n$ ä¸ªç‚¹, $m$ æ¡å¸¦æƒæœ‰å‘è¾¹, çŽ°åœ¨æˆ‘ä»¬ç»™å®šä¸€ä¸ªåºåˆ— $E$ , æˆ‘ä»¬ç§°ä»Ž $1$ åˆ° $n$ çš„ä¸€æ¡è·¯å¾„ä¸ºå¥½çš„, å½“ä¸”ä»…å½“ä»–ç»è¿‡çš„è¾¹çš„ç¼–å·, æ˜¯ $E$ çš„å­åºåˆ—, çŽ°åœ¨è¯·æ‰¾å‡ºæœ€çŸ­çš„å¥½çš„è·¯å¾„, å¦‚æžœæ²¡æœ‰åˆ™è¾“å‡º $-1$

æ€è·¯:

å› ä¸ºç»™å®šäº†å›ºå®šçš„åºåˆ—, é‚£ä¹ˆæˆ‘ä»¬å¯¹äºŽä¸€ä¸ªè·¯å¾„å…¶å®žå°±æ˜¯`é€‰ä¸Žä¸é€‰`ä¸¤ç§é€‰æ‹©, æˆ‘ä»¬å¯ä»¥ `dp` é€’æŽ¨ä¸€ä¸‹, ç”¨è¿™æ¡è·¯å¾„æ›´æ–° `dist[v]`å³å¯

```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n, m, k;
    cin >> n >> m >> k;
    vector<int> a(m), b(m), c(m);
    for (int i = 0; i < m; i++)
    {
        cin >> a[i] >> b[i] >> c[i];
        a[i] -= 1;
        b[i] -= 1;
    }

    vector<long long> dist(n, 1e18);
    dist[0] = 0;
    while (k--)
    {
        int e;
        cin >> e;
        e--;

        if (dist[b[e]] > dist[a[e]] + c[e])
        {
            dist[b[e]] = dist[a[e]] + c[e];
        }
    }

    if (dist[n - 1] == 1e18)
    {
        cout << -1 << endl;
    } else {
        cout << dist[n - 1] << endl;
    }

    return 0;
}
```

## F. XOR on Grid Path (meet-in-the-middle)

é¢˜ç›®:

ç»™å®šä¸€ä¸ª $n * n$ çš„çŸ©é˜µ, æ¯ä¸ªç‚¹ä¸Šéƒ½æœ‰ä¸€ä¸ªæƒå€¼, é—®ä»Žå·¦ä¸Šè§’å‡ºå‘åˆ°å³ä¸‹è§’, å¹¶ä¸”è·¯å¾„æƒå€¼å¼‚æˆ–å’Œä¸º 0 çš„æ–¹æ¡ˆæ•°

æ€è·¯:

1. æ­£å¸¸ DP: æ—¶é—´å¤æ‚åº¦$O(2^{2n})$
2. meet-in-the-middle(åŒå‘å¹¿æœ): ä»Ž $(1, 1)$ å‘å¯¹è§’çº¿æœ, $(n, n)$ ä¹Ÿå‘å¯¹è§’çº¿æœ, æœ€åŽåˆå¹¶ç»“æžœ

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int n;
    cin >> n;

    vector<vector<int>> a(n, vector<int>(n, 0));
    for (int i = 0; i < n; ++i)
    {
        for (int j = 0; j < n; ++j)
        {
            cin >> a[i][j];
        }
    }

    vector<vector<vector<int>>> src(n, vector<vector<int>>(n, vector<int>()));
    src[0][0].push_back(a[0][0]);

    for (int i = 0; i < n; ++i)
    {
        for (int j = 0; j < n; ++j)
        {
            if (i + j >= n)
            {
                continue;
            }
            if (i > 0)
            {
                for (const int x : src[i - 1][j])
                {
                    src[i][j].push_back(x ^ a[i][j]);
                }
            }
            if (j > 0)
            {
                for (const int x : src[i][j - 1])
                {
                    src[i][j].push_back(x ^ a[i][j]);
                }
            }
        }
    }

    vector<vector<vector<int>>> dst(n, vector<vector<int>>(n, vector<int>()));
    dst[n - 1][n - 1].push_back(a[n - 1][n - 1]);

    for (int i = n - 1; i >= 0; --i)
    {
        for (int j = n - 1; j >= 0; --j)
        {
            if (i + j < n - 1)
            {
                continue;
            }
            if (i + 1 < n)
            {
                for (const int x : dst[i + 1][j])
                {
                    dst[i][j].push_back(x ^ a[i][j]);
                }
            }
            if (j + 1 < n)
            {
                for (const int x : dst[i][j + 1])
                {
                    dst[i][j].push_back(x ^ a[i][j]);
                }
            }
        }
    }

    long long ans = 0;
    for (int i = 0; i < n; ++i)
    {
        const int j = n - i - 1;
        sort(begin(dst[i][j]), end(dst[i][j]));

        for (const int x : src[i][j])
        {
            const int val = a[i][j] ^ x;
            ans += upper_bound(begin(dst[i][j]), end(dst[i][j]), val) - lower_bound(begin(dst[i][j]), end(dst[i][j]), val);
        }
    }

    cout << ans << '\n';

    return 0;
}
```

```cpp
#include <bits/stdc++.h>

using namespace std;

unordered_map<int, int> f[N][N];
int a[N][N], ans, n, m;

void dfs1(int x, int y, int v) {
    if(x + y == n) {
        f[x][y][v] ++ ;
        return ;
    }
    else {
        if(x + y < n) dfs1(x + 1, y, v ^ a[x + 1][y]);
        if(x + y < n) dfs1(x, y + 1, v ^ a[x][y + 1]);
    }
}

void dfs2(int x, int y, int v) {
    if(x + y == n) {
        ans += f[x][y][v ^ a[x][y]];
        return ;
    }
    else {
        if(x + y > n) dfs2(x - 1, y, v ^ a[x - 1][y]);
        if(x + y > n) dfs2(x, y - 1, v ^ a[x][y - 1]);
    }
}

signed main() {
    cin >> n;
    for(int i = 1; i <= n ; i ++ )
        for(int j = 1; j <= n ; j ++ )
            cin >> a[i][j];

    dfs1(1, 1, a[1][1]);
    dfs2(n, n, a[n][n]);

    cout << ans << endl;
}
```
