---
# Author
author:
name: TayLock
url: https://iwantdaydayup.github.io

# Date
date: 2022-07-17

# Original
# isOriginal: true

# Category
category:
  - Algorithm
  - AtCoder Beginner Contest

# Tag
tag:
  - Sliding Window
---

# ğŸ§© AtCoder Beginner Contest 260

## # Info & Summary

- **Date:** `2022-07-17`
- **Completion Status:** A âœ… / B âœ… / C âœ… / D âœ… / E âŒ / F âŒ / G âŒ
- **Problem Type**:
  - E: `Sliding Window`

---

## 1. E - æ»‘åŠ¨çª—å£

<https://atcoder.jp/contests/abc260/tasks/abc260_e>

### 1.1 Problem Statement

ç»™å®šæ•´æ•° $M$ å’Œ $N$ ä¸ªæ•´æ•°å¯¹: $(A_1, B_1), (A_2, B_2),..., (A_N, B_N)$, æ»¡è¶³: $1 \le A_i \le B_i \le M$

`Good Sequence`:

- $S$ is a contiguous subsequence of the sequence $(1,2,3,...,M)$

- For all i, S contains at least one of $A_i$ or $B_i$

Let $f(k)$ be the number of possible good sequences of length $k$

Enumerate $f(1), f(2), â€¦, f(M)$

### 1.2 åˆ†æ

æŠŠæ’åˆ— $(1, 2, 3, ..., M)$ ä¸­è¿ç»­çš„ä¸€ä¸ªåŒºé—´ç§°ä½œ $[l, r]$

å¦‚ä¸‹æ€§è´¨:

> è®¾: $1 \le i, j, k, l \le M$, å¦‚æœåŒºé—´ $[k, l]$ åŒ…å«åŒºé—´ $[i, j]$, å³$k \le i \le j \le l$
>
> é‚£ä¹ˆ, å¦‚æœåŒºé—´ $[i, j]$ æ»¡è¶³è¦æ±‚, åŒºé—´$[k, l]$ ä¹Ÿæ»¡è¶³è¦æ±‚

`æ»‘åŠ¨çª—å£`:

- é¦–å…ˆ, ä»¤: $L = R = 1$

- å½“æ»¡è¶³ $L \le M$:

    1. åŒºé—´ $[L, R]$ æ»¡è¶³è¦æ±‚, ç§»åŠ¨å³è¾¹ç•Œ: $R \leftarrow R + 1$

    2. åŒºé—´ $[L, R]$ æ»¡è¶³è¦æ±‚, åˆ™åŒºé—´ $[L, x] (R \le x \le M)$ éƒ½æ»¡è¶³è¦æ±‚, æ›´æ–°ç­”æ¡ˆ

    3. ç§»åŠ¨åŒºé—´å·¦è¾¹ç•Œ: $L \leftarrow L + 1$

### 1.3 code

```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int N, M;
    cin >> N >> M;

    vector<int> A(N), B(N);
    for (int i = 0; i < N; i++) {
        cin >> A[i] >> B[i];
    }

    vector<vector<int>> inv(M + 1);
    for (int i = 0; i < N; i++) {
        inv[A[i]].push_back(i);
        inv[B[i]].push_back(i);
    }

    vector<int> cnt(N), ans(M + 3);

    // è¡¨ç¤ºæ²¡æœ‰è¢«åŒºé—´ [i, j] åŒ…å›´çš„åŒºé—´ [a, b]çš„æ•°é‡(aä¸béƒ½ä¸å‡ºç°åœ¨åŒºé—´[i, j]å†…)
    int cnt_zero = N;

    for (int i = 1, j = 1; i <= M;) {
        // ä¸æ–­æ‰©å±•å³è¾¹ç•Œ `j`
        while (j <= M and cnt_zero != 0) {
            // æ–°çš„åŒºé—´å³è¾¹ç•Œ `j` å¯ä»¥å°†ä¸‹æ ‡é›†åˆinv[j]ä¸­çš„å·¦å³é›†åˆéƒ½è¦†ç›–
            for (auto & x : inv[j]) {
                // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡è¦†ç›–, æ²¡æœ‰è¢«è¦†ç›–çš„åŒºé—´æ•°é‡å‡ä¸€
                if (cnt[x] == 0) cnt_zero--;

                // è¡¨ç¤ºåŒºé—´xè¢«è¦†ç›–
                cnt[x]++;
            }
            j++;
        }

        // åŒºé—´[i, j]ä¸èƒ½æŠŠæ‰€æœ‰åŒºé—´å…¨éƒ¨è¦†ç›–, å¤±è´¥
        if (cnt_zero != 0)
        {
            break;
        }

        // å·®åˆ†æ•°ç»„
        ans[j - i]++;
        ans[M + 1 - i + 1]--;

        // å·¦è¾¹ç•Œ `i` å‘å³ç§»ä¸€æ ¼
        for (auto & x : inv[i]) {
            // æŠŠåŒºé—´å·¦è¾¹ç•Œ `i` èƒ½è¦†ç›–çš„åŒºé—´å…¨éƒ¨ç§»é™¤
            cnt[x]--;

            // æ­¤æ—¶åŒºé—´xä¸èƒ½è¢«åŒºé—´[i, j]è¦†ç›–
            if (cnt[x] == 0) cnt_zero++;
        }

        i++;
    }

    for (int i = 1; i <= M; i++) {
        ans[i] += ans[i - 1];
        cout << ans[i] << " \n"[i == M];
    }
}
```
