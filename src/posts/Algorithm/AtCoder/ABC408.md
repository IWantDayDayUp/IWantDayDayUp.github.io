---
# Author
author:
name: TayLock
url: https://iwantdaydayup.github.io

# Date
date: 2025-05-31

# Original
# isOriginal: true

# Category
category:
  - Algorithm
  - AtCoder Beginner Contest

# Tag
tag:
  - Prefix Sum
  - Greedy
  - DSU
  - BFS
  - DP
  - Math
---

# 🧩 AtCoder Beginner Contest 408

## # Info & Summary

- **Date**: `2025-05-31`
- **Completion Status**: A ✅ / B ✅ / C ✅ / D ✅ / E ❌ / F ❌ / G ❌
- **Problem Type**:

| Problem |      Type(s)      | Data Structure / Algo | 🔥 Key Insight / Mark |
| :-----: | :---------------: | :-------------------: | :-------------------: |
| [D](#D) |      String       |  Prefix Sum / Greedy  |         ⭐🔥          |
| [E](#E) | Bitwise operation |       DSU / BFS       |       ⚠️🧠🛠️🌀        |
| [F](#F) |        DP         |          DP           |          🌀           |
| [G](#G) |       Math        |         Math          |          🌀           |

<!-- @include: ../Readme.md#Emoji -->

---

## 📌 A - Timeout{#A}

![408A](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/408A.4n7yxbklp9.png)

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, S;
    cin >> N >> S;

    vector<int> T(N);
    for (int i = 0; i < N; i++)
    {
        cin >> T[i];
    }

    for (int i = 0; i < N; i++)
    {
        if (T[i] - (i ? T[i - 1] : 0) > S)
        {
            cout << "No" << endl;
            return 0;
        }
    }

    cout << "Yes" << endl;

    return 0;
}
```

## 📌 B - Compression{#B}

![408B](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/408B.39lfta9joe.png)

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;

    vector<int> A(N);
    for (int i = 0; i < N; i++)
    {
        cin >> A[i];
    }

    sort(A.begin(), A.end());
    A.erase(unique(A.begin(), A.end()), A.end());

    cout << A.size() << endl;
    for (int i = 0; i < A.size(); i++)
    {
        cout << A[i] << " \n"[i == A.size() - 1];
    }

    return 0;
}
```

## 📌 C - Not All Covered{#C}

![408C](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/408C.5xaw3n2l0g.png)

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M;
    cin >> N >> M;

    vector<int> A(N + 1);
    for (int i = 0; i < M; i++)
    {
        int L, R;
        cin >> L >> R;
        L--;

        A[L]++;
        A[R]--;
    }

    for (int i = 0; i < N; i++)
    {
        A[i + 1] += A[i];
    }

    cout << *min_element(A.begin(), A.end() - 1) << endl;

    return 0;
}
```

## 📌 D - Flip to Gather{#D}

![408D](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/408D.5q7o87gfky.png)

::: tip
We want all `1`'s to be together in one block(possibly at the start, middle, or end). This is the same as:

- Choose an interval $[l, r)$(possibly empty) and make:
  - All positions inside $[l, r)$ be `1`
  - All positions outside $[l, r)$ be `0`

:::

Let's use some prefix sums:

- $A_i$: the number of `0`'s in $S_1, S_2, ..., S_i$
- $B_i$: the number of `1`'s in $S_1, S_2, ..., S_i$

For empty prefix: $A_0 = 0$ and $B_0 = 0$

::: tip
Given a pair of integers $(l, r)$ $(1 \le l \le r \le N + 1)$, let us consider how many operations are needed so that $S_i = 1$ if and only if $l \le i < r$

- 1. To make all $S_i$ in $[l, r)$ into `1`:
  - Flip all `0`'s in $[l, r)$, this count is represented as $A_{r - 1} - A_{l - 1}$
- 2. To make all $S_i$ outside $[l, r)$ into `0`:
  - Left side $[1, l - 1]$: $B_{l - 1}$
  - right side $[r, N]$: $B_{N} - B_{r - 1}$
  - Total flips for outside: $B_{l - 1} + (B_N - B_{r - 1}) = B_N + B_{l - 1} - B_{r - 1}$

Therfore, total flips for interval $[l, r)$:

$$(A_{r - 1} - A_{l - 1}) + (B_N + B_{l - 1} - B_{r - 1})$$
:::

::: tip
After algebraic manipulation and dropping constants that do not affect min selection, the total flips for interval $[l, r)$ reduces to:

$$(A_{r - 1} - B_{r - 1}) - (A_{l - 1} - B_{l - 1})$$

Then, if we define $C_i = A_i - B_i$, the count can be written as:

$$C_{r - 1} - C_{l - 1}$$

To minimize flips, find the minimum difference $C_{r - 1} - C_{l - 1}$ over all $1 \le l \le r \le N + 1$

This is a classic `minimum range difference` problem, and can be solved in one scan by tracking the minimum so far of $C_{l - 1}$ as we process $r$ form $1$ to $N + 1$

$$\min_{1 \le l \le r \le N + 1} C_{r - 1} - C_{l - 1} = \min_{1 \le r \le N + 1}(C_{r - 1} - \max_{1 \le l \le r}C_{l - 1})$$
:::

```cpp
#include <bits/stdc++.h>

using namespace std;

void solve()
{
    int N;
    string S;
    cin >> N >> S;

    int cnt = count(S.begin(), S.end(), '1');

    int ans = 0;
    int suf = 0;

    for (auto c : S)
    {
        suf = min(0, suf) + (c == '1' ? -1 : 1);
        ans = min(ans, suf);
    }

    ans += cnt;

    cout << ans << endl;

}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```

## 📌 E - Minimum OR Path{#E}

![408E](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/408E.lvzixgick.png)

::: tip
Consider the following decision problem:

> is vertex $N$ reachable from vertex $1$ only via edges with labels $w$ such that $w \mid x = x$?
> For the set of $X$ of such integers $x$, the answer is $\min X$

:::
::: tip
Greedy Bitwise Algorithm:

- Start with the maximal possible `OR` value (all bits set: $2^{30} - 1$)
- Try to "turn off" bits from high to low (bit positions $29$ down to `0`)
- For each bit position $d$, try to turn this bit to `0` in the answer if possible

How to check if we can turn off bit:

- For the current value `ans`, try setting bit $b$ to `0`(i.e., only allow using edges whose weights have zeros at these high bits)
- Do BFS/DFS: only walk through edges where all bits set in `ans` are present in the edge weight(i.e., $(w & ans) == w$)
- If you can reach node $N$, it means you can set this bit to `0`, otherwise, you must set this bit to `1`

:::

::: details

```cpp
#include <bits/stdc++.h>

using namespace std;

struct DSU
{
    vector<int> f, siz;

    DSU() {}
    DSU(int n)
    {
        init(n);
    }

    void init(int n)
    {
        f.resize(n);
        iota(f.begin(), f.end(), 0);
        siz.assign(n, 1);
    }

    int find(int x)
    {
        while (x != f[x])
        {
            x = f[x] = f[f[x]];
        }
        return x;
    }

    bool same(int x, int y)
    {
        return find(x) == find(y);
    }

    bool merge(int x, int y)
    {
        x = find(x);
        y = find(y);

        if (x == y)
        {
            return false;
        }
        siz[x] += siz[y];
        f[y] = x;

        return true;
    }

    int size(int x)
    {
        return siz[find(x)];
    }
};

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M;
    cin >> N >> M;

    vector<array<int, 3>> edge;
    for (int i = 0; i < M; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        u--;
        v--;

        edge.push_back({u, v, w});
    }

    int ans = (1 << 30) - 1;
    // For each bit d from 29 down to 0
    for (int d = 29; d >= 0; d--)
    {
        ans ^= 1 << d;
        DSU dsu(N);
        for (auto [u, v, w]: edge)
        {
            if ((ans | w) == ans)
            {
                dsu.merge(u, v);
            }
        }

        if (!dsu.same(0, N - 1))
        {
            ans |= 1 << d;
        }
    }

    cout << ans << endl;

    return 0;
}
```

:::

```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M;
    cin >> N >> M;

    vector<vector<pair<int, int>>> adj(N);
    for (int i = 0; i < M; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        u--;
        v--;

        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }

    vector<bool> vis(N);
    queue<int> q;

    // For a given mask s, check if you can reach node N-1 from node 0
    // using only edges w such that (w & s) == w (i.e., no forbidden bits)
    auto check = [&](int s)
    {
        fill(vis.begin(), vis.end(), false);
        vis[0] = true;
        q.push(0);

        while (!q.empty())
        {
            int u = q.front();
            q.pop();

            for (auto [v, w] : adj[u])
            {
                if ((w & s) == w && !vis[v])
                {
                    vis[v] = true;
                    q.push(v);
                }
            }
        }

        return vis[N - 1];
    };

    int ans = 0;
    // For each bit d from 29 down to 0
    for (int d = 29; d >= 0; d--)
    {
        // Tentatively try to leave bit d as 0 by checking with mask
        if (!check(ans | ((1 << d) - 1)))
        {
            // If not possible (can't reach N using only edges compatible with this mask),
            // we have to set bit d to 1 in answer
            ans |= 1 << d;
        }
    }

    cout << ans << endl;

    return 0;
}
```

## 📌 F - Athletic{#F}

![408F](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/408F.32i7xune92.png)

::: warning
Hard Problems to Tackle Later
:::

```cpp
// TODO
```

## 📌 G - A/B < p/q < C/D{#G}

![408G](https://github.com/IWantDayDayUp/picx-images-hosting/raw/master/ABC/408G.8vn675auhz.png)

::: warning
Hard Problems to Tackle Later
:::

```cpp
// TODO
```
